//------------------------------------------------------------------------------
// Note : BASE ADV SYSTEM
// Data : 2011/09/30
// File : affine.tjs
// Creator : Kazuyuki Uchino
// Memo : Affine Function
//------------------------------------------------------------------------------
@if (__AFFINE_TJS__== 0)
@set(__AFFINE_TJS__ = 1)

/*
	背景/前景画像の大s小抗による表示を行うプラグインver.1.1
*/

class AffinePlugin
{
	/*-----------------------------------------
	■ メンバオブジェクト
	-----------------------------------------*/
	
	var pluginName = "affine";		// プラグインの名前

	var cx, cy;						// 回中心

	var srot, smag, sx, sy;			// 初期位置
	var drot, dmag, dx, dy;			// 最K位置

	var time;						// 描画rg
	var accel;						// 加速度的な婴を行うか (  : 0 : 正 )

	var storage;					// 画像名
	var index;						// 重ね合わせ序
	var type;						// 描画レイヤ`タイプ
	var targetLayerName;			// 象レイヤ`名
	var targetLayer;				// 象レイヤ`
	
	var opa;						// 不透明度
	var flipud;						// 上下反
	var fliplr;						// 左右反
	var blur;						// ブラ`をかけるか
	var blur_x, blur_y;				// ブラ`のさ

	var blur_inout;					// blur_inoutモ`ド
	var fade;						// fadeモ`ド

	var path;						// 移游恢

	var tempLayer;					// テンポラリレイヤ

	var actionFunc;					// 移游恢糜算v数

	var moving = false;				// 幼髦啸榨楗
	var nextstop;					// 次回停止フラグ

	var startTick;					// _始ティック
	var processTime;				// affine_始からK了までのrg
	var lastTick = 0;				// 前回ハンドラが描画_始したrg
	
	var window;						// ウィンドウオブジェクト
	
	var PriLayer;					//プライマリレイヤ
	
	
	
	
	
	
	/*-----------------------------------------
	■ コンストラクタ
	-----------------------------------------*/
	function AffinePlugin(window, pri)
	{
		this.window   = window;
		
		this.PriLayer = pri;
	}
	
	
	
	
	
	/*-----------------------------------------
	■ デストラクタ
	-----------------------------------------*/
	function finalize()
	{
		// finalize メソッド
		// このクラスの管理するすべてのオブジェクトを明示的に破
		stop();

		invalidate tempLayer if tempLayer !== void;

	}
	
	
	
	
	
	
	/*-----------------------------------------
	■ スタ`トv数
	-----------------------------------------*/
	function startaffine(elm)
	{
		//layer : 象レイヤ
		//storage : 表示画像
		//time : 描画を行っているrg
		//accel : 加速をつけるかどうか
		//cx : 注点X座
		//cy : 注点Y座
		//smag : 初期倍率
		//dmag : 最K倍率
		//srot : 初期角度
		//drot : 最K角度
		//path : 移游恢
		//opacity : 不透明度
		//flipud : 上下反するか
		//fliplr : 左右反するか
		//fade : fadeモ`ド(画像が徐々に消えていくorFれる)
		//blur : 画像をぼかすか
		//blur_inout : blur_inoutモ`ド(画像が徐々にぼやけるor徐々にはっきりする)
		//blur_x : ブラ`の横方向のさ
		//blur_y : ブラ`のk方向のさ
		
		
		//F在のrgを取得しておく
		this.processTime = System.getTickCount();
		
		
		// 象レイヤ`のO定
		this.targetLayer = elm.layer;
		
		
		// ブラ`のさのO定
		this.blur_x = elm.blur_x;
		this.blur_y = elm.blur_y;
		
		// テンポラリレイヤを_保
		{
			// 元画像のO定
			this.storage = elm.storage;
			
			if(tempLayer === void)
			{
				tempLayer = new Layer(window, PriLayer);
				
				//storageが指定されていないrは、象レイヤ`の画像を使用
				if(storage == "")
				{
					tempLayer.assignImages(elm.layer);
				}
				else
				{
					tempLayer.loadImages(this.storage, clNone);
				}
				
				
				
				// 上下左右反、ブラ`のO定
				if(elm.flipud == ""){
					this.flipud = false;
				}else{
					this.flipud = elm.flipud;
				}
				
				
				if(elm.fliplr == ""){
					this.fliplr = false;
				}else{
					this.fliplr = elm.fliplr;
				}
				
				
				if(elm.blur == ""){
					this.blur = false;
				}else{
					this.blur = elm.blur;
				}
				
				
				if(flipud){
					tempLayer.flipUD();
				}
				
				
				if(fliplr){
					tempLayer.flipLR();
				}
				
				
				if(blur){
					tempLayer.doBoxBlur(blur_x, blur_y);
				}
			
			}
			
			tempLayer.setSizeToImageSize();
		}
		
		
		
		
		{
			// 不透明度のO定
			this.opa = (elm.opacity !== void) ? +elm.opacity : 255;
			targetLayer.opacity = +opa;
			
			
			// fadeモ`ドのO定
			if(elm.fade == ""){
				this.fade = false;
			}else{
				this.fade = elm.fade;
			}
			
			
			
			// ブラ`イン99アウトモ`ドのO定
			if(elm.blur_inout == ""){
				this.blur_inout = false;
			}else{
				this.blur_inout = elm.blur_inout;
			}
			
			
			
			// pathを分解
			this.path = elm.path;
			var array = [].split("(), ", path, , true);
			
			this.sx = array[0];
			this.sy = array[1];
			this.dx = array[2];
			this.dy = array[3];
			
			// 回中心のO定
			if(elm.cx == "" || elm.cx == 'c'){
				this.cx = tempLayer.imageWidth \ 2;
			}else if( typeof +elm.cx == 'Real'){
				this.cx = tempLayer.imageWidth * +elm.cx;
			}else{
				this.cx = (int)elm.cx;
			}
			
			
			if(elm.cy == "" || elm.cy == 'c'){
				this.cy = tempLayer.imageHeight \ 2;
			}else if( typeof +elm.cy == 'Real'){
				this.cy = tempLayer.imageHeight * +elm.cy;
			}else{
				this.cy = (int)elm.cy;
			}
			
			
			// 初期位置のO定
			if(elm.srot == ""){
				this.srot = (real)0;
			}else if( typeof +elm.srot == 'Real'){
				this.srot = Math.PI * +elm.srot;
			}else{
				this.srot = +elm.srot;
			}
			
			
			//初期倍率
			if(elm.smag == ""){
				this.smag = (int)1;
			}else{
				this.smag = (real)elm.smag;
			}
			
			
			if(sx == "" || sx == 'c'){
				sx = targetLayer.imageWidth / 2;
			}else if( typeof +sx == 'Real'){
				sx = targetLayer.imageWidth * +sx;
			}else{
				sx = (int)sx;
			}
			
			
			if(sy == "" || sy == 'c'){
				sy = targetLayer.imageHeight / 2;
			}else if( typeof +sy == 'Real'){
				sy = targetLayer.imageHeight * +sy;
			}else{
				sy = (int)sy;
			}
			
			
			// 最K位置のO定
			if(elm.drot == ""){
				this.drot = (real)0;
			}else if( typeof +elm.drot == 'Real'){
				this.drot = Math.PI * +elm.drot;
			}else{
				this.drot = +elm.drot;
			}
			
			
			if(elm.dmag == ""){
				this.dmag = (int)1;
			}else{
				this.dmag = (real)elm.dmag;
			}
			
			
			if(dx == ""){
				dx = sx;
			}else if(dx == 'c'){
				dx = targetLayer.imageWidth / 2;
			}else if( typeof +dx == 'Real'){
				dx = targetLayer.imageWidth * +dx;
			}else{
				dx = (int)dx;
			}
			
			
			if(dy == ""){
				dy = sy;
			}else if(dy == 'c'){
				dy = targetLayer.imageHeight / 2;
			}else if( typeof +dy == 'Real'){
				dy = targetLayer.imageHeight * +dy;
			}else{
				dy = (int)dy;
			}
			
			
			// 描画rgのO定
			if(elm.time == ""){
				this.time = 1000;
			}else{
				this.time = (int)elm.time;
			}
			
			
			// 加速度のO定
			if(elm.accel == ""){
				this.accel = 0;
			}else{
				this.accel = (real)elm.accel;
			}
		}
		
		
		@if(_DEBUG == 1)
		// コンソ`ルにaffineの情螭虺隽
		//System.inform("■affine : layer = " + targetLayerName + ";" + "; storage = " + storage + ";
		//time = " + time + ";
		//(cx,cy) = " + "("+cx+","+cy+")");
		@endif
		
		
		// 移游恢糜算v数のO定
		if(srot == 0 && drot == 0)// 回しないならoperateStretchを使用
		{
			actionFunc = stretchMover;
			
			@if(_DEBUG == 1)
			//dm("■operateStretch");
			@endif
		}
		else
		{
			actionFunc = affineMover;
			
			@if(_DEBUG == 1)
			//System.inform("■operateAffine : srot = " + srot + "; drot =" + drot);
			@endif
		}
		
		
		// 描画の_始
		// timeが0以下ならすぐにK了I理へ
		if(time <= 0){
			targetLayer.visible = true;
			finish();
		}else{
			// 初期位置に表示
			actionFunc(0);
			targetLayer.visible = true;
			
			// _始
			startTick = System.getTickCount();
			System.addContinuousHandler(continuousHandler);
			moving = true;
			nextstop = false;
		}
	}
	
	
	
	
	
	
	
	/*-----------------------------------------
	// 通常用、移游恢糜算v数
	-----------------------------------------*/
	function affineMover(tm)
	{
		// 位置算
		// tm は 0.0(_始点) ～ 1.0(K了点) のgで浠する涫なので、
		// これを元にして位置を算する
		var r = (drot - srot) * tm + srot;
		var s = (dmag - smag) * tm + smag;
		var tx = (dx - sx) * tm + sx;
		var ty = (dy - sy) * tm + sy;

		var rc = Math.cos((Math.PI/180) * r);
		var rs = Math.cos((Math.PI / 2) - (Math.PI/180) * r);

		var m00, m01, m10, m11, mtx, mty;  // アフィンQ行列パラメ`タ
		m00 = s * rc;
		m01 = s * -rs;
		m10 = s * rs;
		m11 = s * rc;
		mtx = (m00*-cx) + (m10*-cy) + tx;
		mty = (m01*-cx) + (m11*-cy) + ty;

		// fadeモ`ド用不透明度の算
		var opa2;

		if(fade == 'in')
		{
			opa2 = int(( 255 * tm));
		}
		else if(fade == 'out')
		{
			opa2 = int(255 - ( 255 * tm));
		}
		else
		{
			opa2 = 255;
		}

		// blur_inoutモ`ド用ブラ`のさの算
		var bx, by;

		if(blur_inout == 'in' || blur_inout == 'out')
		{
			if(blur_inout == 'in')
			{
				bx = int(blur_x - (blur_x * tm));
				by = int(blur_y - (blur_y * tm));
			}
			else
			{
				bx = int(blur_x * tm);
				by = int(blur_y * tm);
			}
		}
		
		// m00 m01 m10 m11 mtx mty 位置に移
		targetLayer.visible = true;
		
		// レイヤ`を一度クリアする
		targetLayer.fillRect( 0,0, targetLayer.imageWidth,targetLayer.imageHeight, 0 );

		// アフィンQ送
		if(targetLayer.type == ltOpaque)// レイヤ`タイプがltOpaqueならstFastLinear(形ag)
		{
			//dm("stFastLinear");
			
			targetLayer.operateAffine(
			tempLayer,
			0, 0,
			tempLayer.imageWidth, tempLayer.imageHeight,
			'true',
			m00, m01,
			m10, m11,
			mtx, mty,
			omOpaque,
			opa2,
			stFastLinear
			);
		}
		else
		{
			targetLayer.operateAffine(
			tempLayer,
			0, 0,
			tempLayer.imageWidth, tempLayer.imageHeight,
			'true',
			m00, m01,
			m10, m11,
			mtx, mty,
			omAuto,
			opa2,
			stNearest
			);
		}
		
		
		// blur_inoutモ`ドなら、ブラ`をg行
		if(blur_inout == 'in' || blur_inout == 'out'){
			targetLayer.doBoxBlur(bx, by);
		}
	}
	
	
	
	
	
	
	/*-----------------------------------------
	// o回用、移游恢糜算v数
	-----------------------------------------*/
	function stretchMover(tm)
	{
		// 位置算
		// tm は 0.0(_始点) ～ 1.0(K了点) のgで浠する涫なので、
		// これを元にして位置を算する
		var s = (dmag - smag) * tm + smag;
		var tx = (dx - sx) * tm + sx;
		var ty = (dy - sy) * tm + sy;

		var m00, m01, mtx, mty;

		m00 = tempLayer.imageWidth * s;
		m01 = tempLayer.imageHeight * s;
		mtx = (-cx) * s + tx;
		mty = (-cy) * s + ty;

		// fadeモ`ド用不透明度の算
		var opa2;

		if(fade == 'in')
		{
			opa2 = int(( 255 * tm));
		}
		else if(fade == 'out')
		{
			opa2 = int(255 - ( 255 * tm));
		}
		else
		{
			opa2 = 255;
		}
		
		// blur_inoutモ`ド用ブラ`のさの算
		var bx, by;

		if(blur_inout == 'in' || blur_inout == 'out')
		{
			if(blur_inout == 'in')
			{
				bx = int(blur_x - (blur_x * tm));
				by = int(blur_y - (blur_y * tm));
			}
			else
			{
				bx = int(blur_x * tm);
				by = int(blur_y * tm);
			}
		}

		// m00 m01 mtx mty 位置に移
		targetLayer.visible = true;
		
		// レイヤ`を一度クリアする
		targetLayer.fillRect( 0,0, targetLayer.imageWidth,targetLayer.imageHeight, 0 );

		// 大s小送
		if(targetLayer.type == ltOpaque)
		{
			//dm("stFastLinear");
			
			targetLayer.operateStretch(
			mtx, mty,
			m00, m01,
			tempLayer,
			0, 0,
			tempLayer.imageWidth, tempLayer.imageHeight,
			omOpaque,
			255,
			stFastLinear
			);
		}
		else
		{
			targetLayer.operateStretch(
			mtx,mty,
			m00,m01,
			tempLayer,
			0, 0, 
			tempLayer.imageWidth, tempLayer.imageHeight, 
			omAuto, 
			255, 
			stNearest
			);
		}
		
		
		// blur_inoutモ`ドなら、ブラ`をg行
		if(blur_inout == 'in' || blur_inout == 'out'){
			targetLayer.doBoxBlur(bx, by);
		}
	}
	
	
	
	
	/*-----------------------------------------
	■ 移娱v数
	-----------------------------------------*/
	function continuousHandler(tick)
	{
		// ハンドラ
		if(nextstop)
		{
			// K了
			finish();
			return;
		}

		// rgを得る
		var tm = tick - startTick;
		tm /= time;
		if(tm >= 1)
		{
			// 描画K了フラグON
			nextstop = true;
			tm = 1;
			return;
		}
		else
		{
			var intervalTime = System.getTickCount() - lastTick;

			if(intervalTime > 15)// ハンドラが15ms以内に呼ばれたら、描画しない
			{
				// 加速算
				if(accel < 0)
				{
					// 上弦 ( 最初が婴が早く、徐々にWくなる )
					tm = 1.0 - tm;
					tm = Math.pow(tm, -accel);
					tm = 1.0 - tm;
				}
				else if(accel > 0)
				{
					// 下弦 ( 最初は婴がWく、徐々に早くなる )
					tm = Math.pow(tm, accel);
				}

				lastTick = System.getTickCount();
				
				// 移
				actionFunc(tm);
			}
		}
	}
	
	
	
	
	
	/*-----------------------------------------
	■ K了v数
	-----------------------------------------*/
	function finish()
	{
		// 最K位置に移
		actionFunc(1.0);

		// 回ズ`ムのK了
		stop(); // 停止
	}
	
	
	
	
	
	/*-----------------------------------------
	■ 回停止v数
	-----------------------------------------*/
	function stop()
	{
		// 停止
		if(moving)
		{
			System.removeContinuousHandler(continuousHandler);
			moving = false;
			//System.inform("■affineg行rg :"+ (System.getTickCount() - processTime) +"ms■");
		}
		
		
		if(tempLayer !== void){
			invalidate tempLayer ;
		}
		
		tempLayer   = void;
		targetLayer = void;
		
	}
	
	
	
	
	
	
	
	/*-----------------------------------------
	// レイヤの画像を回99大99s小します
	// (指定できる属性)
	// elm.scale : k99横方向共通大率(%)
	// elm.xscale : 横方向大率(%)
	// elm.yscale : k方向大率(%)
	// elm.angle : 回する角度
	-----------------------------------------*/
	function rotateImage( layer, elm )
	{
		var base_w = layer.width;
		var base_h = layer.height;
		
		var tmpLayer = new Layer(window, layer); // 一rレイヤを作ります
		
		tmpLayer.assignImages(layer); // 一rレイヤに操作象のレイヤの画像をコピ`します
		
		// アフィンQのパラメ`タを算します ※は割郅筏蓼
		var angle = +elm.angle * Math.PI / 180;
		
		var xscale = (elm.xscale !== void ? +elm.xscale : (elm.scale !== void ? +elm.scale : 100)) / 100;
		
		var yscale = (elm.yscale !== void ? +elm.yscale : (elm.scale !== void ? +elm.scale : 100)) / 100;
		
		var sin = Math.sin(angle), cos = Math.cos(angle);
		
		var xw = xscale * tmpLayer.imageWidth, xh = xscale * tmpLayer.imageHeight;
		
		var yw = yscale * tmpLayer.imageWidth, yh = yscale * tmpLayer.imageHeight;
		
		var ofsx, ofsy;
		
		if(sin >= 0.0)
		{
			if(cos >= 0.0)
			{
				ofsx = yh * sin;
				ofsy = 0.0;
			}
			else
			{
				ofsx = -xw * cos + yh * sin;
				ofsy = -yh * cos;
			}
		}
		else
		{
			if(cos < 0.0)
			{
				ofsx = -xw * cos;
				ofsy = -xw * sin - yh * cos;
			}
			else
			{
				ofsx = 0.0;
				ofsy = -xw * sin;
			}
		}

		var width = (int)(xw * Math.abs(cos) + yh * Math.abs(sin)); // Q後の幅を算します
		
		var height = (int)(xw * Math.abs(sin) + yh * Math.abs(cos)); // Q後の高さを算します
		
		width = 1 if width < 1; // 幅は必ず 1 ピクセル以上になるようにします
		
		height = 1 if height < 1; // 高さも必ず 1 ピクセル以上になるようにします
		
		layer.setImageSize(width, height); // 操作象のレイヤのサイズを涓します
		
		layer.setSizeToImageSize(); // 操作象のレイヤのサイズを画像のサイズに合わせます
		
		// 操作象のレイヤの中性色を一r的に透明色(0x00000000)にO定します
		var neutralColor = layer.neutralColor;
		
		layer.neutralColor = 0x00000000;

		// 一rレイヤの画像を回99大99s小して操作象のレイヤにコピ`します
		layer.affineCopy(tmpLayer, 0, 0, tmpLayer.imageWidth, tmpLayer.imageHeight, true, xscale * cos, xscale * sin, -yscale * sin, yscale * cos, ofsx, ofsy, stFastLinear, true);

		// 操作象のレイヤの中性色を元にします
		layer.neutralColor = neutralColor;

		invalidate tmpLayer; // 一rレイヤはもう必要ないのでo炕します
		
		//座摔す
		//Debug.message("w:"+width+" h:"+height);
		
		layer.left -= ((layer.width - base_w)) \ 2;
		
		layer.top  -= ((layer.height - base_h))\ 2;
		
	}
}

@endif

cos)); // 澶寰楂瑷绠俱
		
		width = 1 if width < 1; // 骞蹇 1 汇浠ヤ俱
		
		height = 1 if height < 1; // 楂蹇 1 汇浠ヤ俱
		
		layer.setImageSize(width, height); // 浣瀵捐薄ゃゃ点ゃ恒澶淬俱
		
		layer.setSizeToImageSize(); // 浣瀵捐薄ゃゃ点ゃ恒诲点ゃ恒俱
		
		// 浣瀵捐薄ゃゃ涓ц层涓(0x00000000)瑷瀹俱
		var neutralColor = layer.neutralColor;
		
		layer.neutralColor = 0x00000000;

		// 涓ゃゃ诲杌绘″ぇ荤府灏浣瀵捐薄ゃゃ炽笺俱
		layer.affineCopy(tmpLayer, 0, 0, tmpLayer.imageWidth, tmpLayer.imageHeight, true, xscale * cos, xscale * sin, -yscale * sin, yscale * cos, ofsx, ofsy, stFastLinear, true);

		// 浣瀵捐薄ゃゃ涓ц层汇俱
		layer.neutralColor = neutralColor;

		invalidate tmpLayer; // 涓ゃゃ蹇瑕х″瑰俱
		
		//搴ф汇
		//Debug.message("w:"+width+" h:"+height);
		
		layer.left -= ((layer.width - base_w)) \ 2;
		
		layer.top  -= ((layer.height - base_h))\ 2;
		
	}
}

@endif

